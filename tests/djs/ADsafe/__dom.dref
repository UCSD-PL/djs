weak (~htmlElts       : { Arr(Ref(~htmlElt)) | (packed v)} > lArrPro)
weak (~lChecked       : { Arr(Bool)          | (packed v)} > lArrPro)
weak (~lClassNames    : { Arr(Str)           | (packed v)} > lArrPro)
weak (~lADsafeMarks   : { Arr(Str)           | (packed v)} > lArrPro)
weak (~lNames         : { Arr(Str)           | (packed v)} > lArrPro)
weak (~lPackedValues  : { Arr(Str)           | (packed v)} > lArrPro)
weak (~lValues        : { Arr(Top)           | (packed v)} > lArrPro)
weak (~lOffsetHeights : { Arr(Num)           | (packed v)} > lArrPro)
weak (~lOffsetWidths  : { Arr(Num)           | (packed v)} > lArrPro)
weak (~lKeys          : { Arr(Str)           | (packed v)} > lArrPro)
weak (~lStyles        :   Arr(Str)                         > lArrPro)

weak (~lFuncs         : { Arr((Top,Top)-> Top)| (packed v)} > lArrPro)

weak (~lEvent     : { Dict | 
  (and 
    (*(and (has v "altKey")           (Bool (sel v "altKey")))*)
    (*(and (has v "bubble")           ((sel v "bubble") :: () -> Top))*)
    (*(implies (has v "ctrlKey")          (Bool (sel v "ctrlKey")))*)
    (*(implies (has v "shiftKey")         (Bool (sel v "shiftKey")))*)
    
    (implies (has v "cancelBubble")     (Bool (sel v "cancelBubble")))
    (implies (has v "key")              (Str (sel v "key")))
    (implies (has v "preventDefault")   ((sel v "preventDefault")  :: () -> Top))
    (implies (has v "srcElement")       ((sel v "srcElement")      :: Ref(~htmlElt)))
    (implies (has v "stopPropagation")  ((sel v "stopPropagation") :: () -> Top))
    (implies (has v "target")           ((sel v "target")          :: Ref(~htmlElt)))
    (implies (has v "that")             ((sel v "that")            :: Ref(~htmlElt)))
    (implies (has v "type_")            (Str (sel v "type_")))
    (implies (has v "charCode")         (Int (sel v "charCode")))
    (implies (has v "keyCode")          (Int (sel v "keyCode")))

    (* Hacking this in as an asssumption *)
    (implies (has v "array")            ((sel v "array") :: Ref (~lFuncs)))
    
    (* TODO: giving a restricted type here *)
    (implies (has v "__farray__")        ({(= (tag v) "function")} (sel v "__farray__")))
  )} > lObjPro)


weak (~lSafeEvent     : { Dict | 
  (and 
    (*(and (has v "altKey")           (Bool (sel v "altKey")))*)
    (*(and (has v "bubble")           ((sel v "bubble") :: () -> Top))*)
    (*(implies (has v "ctrlKey")          (Bool (sel v "ctrlKey")))*)
    (*(implies (has v "shiftKey")         (Bool (sel v "shiftKey")))*)
    
    (implies (has v "cancelBubble")     (Bool (sel v "cancelBubble")))
    (implies (has v "key")              (Str (sel v "key")))
    (implies (has v "preventDefault")   ((sel v "preventDefault")  :: () -> Top))
    (implies (has v "srcElement")       ((sel v "srcElement")      :: Ref(~lBunch)))
    (implies (has v "stopPropagation")  ((sel v "stopPropagation") :: () -> Top))
    (implies (has v "target")           ((sel v "target")          :: Ref(~lBunch)))
    (implies (has v "that")             ((sel v "that")            :: Ref(~lBunch)))
    (implies (has v "type_")            (Str (sel v "type_")))
    (implies (has v "charCode")         (Int (sel v "charCode")))
    (implies (has v "keyCode")          (Int (sel v "keyCode")))

    (* Hacking this in as an asssumption *)
    (implies (has v "array")            ((sel v "array") :: Ref (~lFuncs)))
    
    (* TODO: giving a restricted type here *)
    (implies (has v "__farray__")        ({(= (tag v) "function")} (sel v "__farray__")))
  )} > lObjPro)



(*  altKey          : Bool,
  bubble          : (this: Ref(~lEvent))-> Top,
  cancelBubble    : Bool,
  ctrlKey         : Bool,
  key             : Str, 
  preventDefault  : (this: Ref(~lEvent)) -> Top,
  shiftKey        : Bool,
  srcElement      : Ref(~htmlElt),
  stopPropagation : (this: Ref(~lEvent))-> Top,
  target          : Ref(~htmlElt),    (* could also be Ref(~lEventTarget) *)
  that            : Ref(~lBunch),
  type_           : Str,
  _               : Bot                         
} > lObjPro)*)

weak (~lEventTarget: { } > lObjPro)

weak (~lSelector : { Dict |
  (and 
    (has v "op") (Str (sel v "op"))
   (* Don't need this. In function quest. If the field of hunter is a function
    * this should imply that we have one of the following cases. But this won't
    * work for the population of selectors at parse_query. *)
  (*(and 
    (has v "op") ({(or  (= v "empty_") 
                        (= v "plus")
                        (= v "greater") 
                        (= v "pound") 
                        (= v "slash") 
                        (= v "star"))
                  } (sel v "op") )*)
    (implies (has v "name") (Str (sel v "name"  )))
    (implies (has v "value") (Str (sel v "value")))
  )} > lObjPro)
 
weak (~lRange : {
  text: Str,
  expand: (this:Ref(~lRange), Str) -> Bool
} > lObjPro)
  
weak (~lQuery: { Arr(Ref(~lSelector)) | (packed v) } > lArrPro)

weak (~lBunches: {Arr(Ref(~lBunch))|(packed v)} > lArrPro)

weak (~lBunch    : {
  "___nodes___"  : Ref(~htmlElts),
  "___star___"   : Bool,
  _              : Bot
} > lBunchProto)

weak (~lStyle : {
    visibility   : Str,
    cssFloat     : Str,
    styleFloat   : Str
} > lObjPro)

weak (~lSelection: { createRange: () -> Ref(~lRange) }  > lObjPro) 


weak (~htmlElt: {
    "___ on ___"         : Ref(~lEvent),
    "___adsafe root___"  : Str,
    "_adsafe mark_"      : Str,
    addEventListener     : (this: Ref(~htmlElt), Str, (Ref(~lEvent)) -> Top, Bool) -> Top,
    appendChild          : (this: Ref(~htmlElt), Ref(~htmlElt)) -> Top,
    autocomplete         : Str,
    blur                 : (this: Ref(~htmlElt)) -> Top,
    change               : Ref(~lEvent),
    checked              : Bool,
    childNodes           : Ref(~htmlElts),
    className            : Str,
    (* Not sure if clone(boolean) should be added her *)
    clone                : (this: Ref(~htmlElt), Bool) -> Ref(~htmlElt),
    cloneNode            : (this: Ref(~htmlElt), deep:Bool) -> Ref(~htmlElt),
    createTextRange      : () -> Ref(~lRange), 
    currentStyle         : Ref(~lStyle),
    disabled             : Bool,
    document             : Ref(~htmlElt),
    fire                 : (Top) -> Top,
    firstChild           : Ref(~htmlElt),
    focus                : () -> Top,   
    getComputedStyle     : (this: Ref(~htmlElt), node : Ref(~htmlElt), str  : Str) -> Ref(~lStyle),
    (*getElementsByTagName : [;L] (this: Ref(~htmlElt), name : Str) / () -> Ref(L) / (L: {Arr(Ref(~htmlElt))|(packed v)} > lArrPro),*)
    getElementsByTagName : (this: Ref(~htmlElt), name : Str) -> Ref(~htmlElts),
    getParent            : (this: Ref(~htmlElt)) -> Ref(~htmlElt),
    insertBefore         : (this: Ref(~htmlElt), Ref(~htmlElt), Ref(~htmlElt)) -> Top,
    name                 : Str,
    nextSibling          : Ref(~htmlElt),
    nodeName             : Str,
    nodeValue            : Str,
    offsetHeight         : Num,
    offsetWidth          : Num,
    onchange             : (this:Ref(~lEvent), Ref(~lEvent)) -> Top,
    parent               : Ref(~htmlElt),
    parentNode           : Ref(~htmlElt),
    removeChild          : (this: Ref(~htmlElt), Ref(~htmlElt)) -> Top,
    removeElement        : (this: Ref(~htmlElt), Ref(~htmlElt)) -> Top,
    replaceChild         : (this: Ref(~htmlElt), Ref(~htmlElt), Ref(~htmlElt)) -> Top,
    select               : (this: Ref(~htmlElt)) -> Top,   
    selectionEnd         : Int,
    selectionStart       : Int,
    style                : Ref(~lStyle),
    tagName              : Str,
    title                : Str,
    value                : Top
  } > lObjPro)

weak (~lDocument   : {
    createDocumentFragment : (this: Ref(~lDocument)) -> Ref(~htmlElt),
    createElement          : (this: Ref(~lDocument), s: Str) -> Ref(~htmlElt),
    createTextNode         : (this: Ref(~lDocument), s: Str) -> Ref(~htmlElt),
    defaultView            : Ref(~htmlElt),
    getElementById         : (this: Ref(~lDocument), s: Str) -> Ref(~htmlElt),
    selection              : Ref(~lSelection)
  } > lObjPro)

weak (~lDom: { 
    append    : (Ref(~lBunch))   -> Ref(~lDom),
    combine   : (Ref(~lBunches)) -> Ref(~lBunch),
    count     : ()               -> Int,
    ephemeral : (Ref(~lBunch))   -> Ref(~lDom),
    fragment  : (Ref(~lBunch))   -> Ref(~lBunch),
    prepend   : (Ref(~lBunch))   -> Ref(~lDom),
    q         : (Ref(text))      -> Ref(~lBunch),
    remove    : ()               -> Top,
    row       : (Top)            -> Ref(~lBunch),
    tag_: (tag_: Str, type_: Str, name: Str) -> Ref(~lBunch),
    text:{( and (v:: (text: Str) / (lT: {Arr(Str)|(packed v)} > lArrPro) -> Top / sameType) (v:: (text: Ref(lT)) / (lT: {Arr(Str)|(packed v)} > lArrPro) -> Top / sameType) )}
}  > lObjPro) 

weak (~lF: { _: Bot } > lFProto)


weak (~lId: { } > lObjPro)
weak (~lLib: { } > lObjPro)

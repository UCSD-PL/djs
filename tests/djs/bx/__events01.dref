
val __eltOfEvt :: (this:Top, Evt) -> Ref(~elt)

val __textOfEvt :: (this:Top, Evt) -> Str

(* this is called jsonValue in IBEX *)
val __jsonOfEvt :: (this:Top, Evt) -> Json

val __jsonResponse :: (this:Top, Evt, Json) -> Json

val __jsonRequest :: (this:Top, Json) -> Top

val __jsonOfString :: (this:Top, Str) -> Json

val __recvMessages :: (this:Top, (this:Top, Evt) -> Top) -> EvtHandler

val __query :: (this:Top, Str, Json) -> Json

val __jsonFromDjs :: (this:Top, x:Ref) / (x: Dict > x.pro) -> Json / same

val __stringsOfJson :: [;L]
        (this:Top, Json) / ()
     -> Ref(L) / (L: {Arr(Str)|(and (packed v) (>= (len v) 0))} > lArrPro)

val __attachEvent :: (this:Top, Ref(~elt), Str)
                  -> ((this:Top, Evt) -> Top)
                  -> EvtHandler

val __detach :: (this:Top, EvtHandler) -> Int

(* TODO update the world encoding *)

val __makeWorld :: [A] (this:Top, A) -> {World|(v :: A)}

val __getWorld :: [A] (this:Top, {World|(v :: A)}) -> A

val __reactPar :: [A] ( this:Top
                      , {World|(v :: A)}
                      , ((this:Top, Evt) -> Top) -> EvtHandler
                      , Top (* TODO (world 'a -> evt -> option 'a) *)
                      )
                   -> EvtHandler

val __contentScript :: (this:Top, Str) -> Top


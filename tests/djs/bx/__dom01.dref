
weak (~elt: Empty > lEltPro)

weak (~doc: Empty > lDocPro)

val theEltPro :: {

(* Metadata queries *)

  getChild :
      (this:Ref(~elt), Int)
   -> {Ref(~elt)|(eltParentChild this v)}

, children :
      [;L] (this:Ref(~elt)) / ()
   -> Ref(L) / (L: {Arr(Ref(~elt))|(packed v)} > lArrPro)

  (* NOTE: for now, not supporting the syntax {Ref(~elt)!|p} *)
, parentNode :
      (this:Ref(~elt))
   -> {Ref(~elt)|(and (not (= v null)) (eltParentChild v this))}

, tagName :
      (this:Ref(~elt))
   -> {Str|(eltTagName this v)}

(* Protected access to data *)

, getAttr :
      (this:Ref(~elt), k:{Str|(canReadAttr this k)})
   -> {Str|(and (eltAttr this k v) (flowsFromTo this v))}

, setAttr :
      (this:Ref(~elt), k:Str, y:{Str|(canWriteAttr this k v)})
   -> {(eltAttr this k y)}

, getValue :
      (this:{Ref(~elt)|(canReadValue v)})
   -> {Str|(eltTextValue this v)}

, setValue :
      (this:{Ref(~elt)|(canWriteValue v)}, s:Str)
   -> {Ref(~elt)|(eltTextValue this s)}

, createElt :
      (this:Ref(~doc), t:Str)
   -> {Ref(~elt)|(and (eltDoc v this) (eltTagName v t) (canEdit v))}

  (* NOTE: DOM.f9 uses canAppend par, but the paper uses canAppend par ch *)
, appendChild :
      (* (this:Ref(~elt), child:{Ref(~elt)|(canAppend this)}) *)
      (this:Ref(~elt), child:{Ref(~elt)|(canAppend this v)})
   -> {(eltParentChild this child)}

(*
, getStyle : 
      (this:Ref(~elt))
   -> {Sty|(eltStyle this v)}
*)
, getStyle : 
      (this:Ref(~elt))
   -> {Ref(~sty)|(eltStyle this v)}

, isTextNode :
      (this:Ref(~elt))
   -> Bool

, numChildren :
      (this:Ref(~elt))
   -> Int

, _ : Bot

}

val theDocPro :: {

  body :
      (this:Ref(~doc))
   -> {Ref(~elt)|(and (eltDoc v this) (eltTagName v "body"))}

, domain : 
      (this:Ref(~doc))
   -> {Str|(docDomain this v)}

, createTextNode : 
      (this:Ref(~doc), s:Str)
   -> {Ref(~elt)|(and (eltDoc v this) (eltTextValue v s))}

, getSelectedText :
      (this:{Ref(~doc)|(canReadSelection v)})
   -> {Str|(selection v)}

, getEltById :
      (this:Ref(~doc), s:Str)
   -> {Ref(~elt)|(and (eltDoc v this) (eltAttr v "id" s))}

(* some callers want the eltDoc predicate, but some don't.
   since array subtyping is bivariant, can't just include it.
   no matter, nested refinements trick to the rescue!
*)
, getEltsByTagName : 
      [A;L] (this:Ref(~doc), t:Str) / ()
   -> Ref(L)
    / (L: {Arr({Ref(~elt)|(and (eltTagName v t)
                               (implies (0 :: A) (eltDoc v this)))}
              )|(packed v)} > lArrPro)

, getEltsByClassName : 
      [A;L] (this:Ref(~doc), x:Str) / ()
   -> Ref(L)
    / (L: {Arr({Ref(~elt)|(and (eltAttr v "className" x)
                               (implies (0 :: A) (eltDoc v this)))}
              )|(packed v)} > lArrPro)

, activeElt : 
      (this:Ref(~doc))
   -> {Ref(~elt)|(eltDoc v this)}

, _ : Bot

}

heap (
  lEltPro : theEltPro > lROOT
, lDocPro : theDocPro > lROOT
)

(* "the end" *)
